---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
install.packages("dslabs")
## 2.2.1 objects

a<-1
b<-1
c<- -1

a
#> [1] 1

print(a)
#> [1] 1

## 2.2.2 The workspace
ls()
#> [1] "a" "b" "c"

(-b + sqrt(b^2-4*a*c))/(2*a)
#> [1] 0.618304

(-b - sqrt(b^2-4*a*c))/(2*a)
#> [1] -1.618034 

## 2.2.3 Functions

log(8)
#> [1] 2.079442

log(a)
#> [1] 0

help("log") ## 얘 누르면 help에 log에 대한 얘기가 뜬다!
?log ## 얘도!

args(log)
#> function (x, base=exp(1))
#> NULL

log(8, base=2)
#> [1] 3

log(x=8, base=2)
#> [1] 3

log(8,2)
#> [1] 3

log(base=2, x=8)
#> [1] 3

2^3
#> [1] 8

help("+")
?"+"
help(">")
?">"

## 2.2.4 Other prebuilt objects
data()   ## R data sets가 열림
co2  ## CO2 concentration data를 보여줌

pi
#> [1] 3.141593
Inf+1
#> [1] Inf

## 2.2.5 Variable names

install.packages <- 2

solution_1 <- (-b + sqrt(b^2-4*a*c))/(2*a)
solution_2 <- (-b - sqrt(b^2-4*a*c))/(2*a)

## 2.2.7 Motivating scripts
a <- 3
b <- 2
c <- -1
(-b+sqrt(b^2-4*a*c))/(2*a)
#> [1] 0.3333333
(-b-sqrt(b^2-4*a*c))/(2*a)
#> [1] -1

## 2.3 Exercise
## 1. What is the sum of the first 100 positive integers? The formula for the sum of integers 1 thought n is n(n+1)/2. Define n=100 and then use R to compute the sum of 1 through 100 using the formula. what is the sum?

n <- 100
n*(n+1)/2
#> [1] 5050

## 2. Now use the same formula to compute the sum of the integers from 1 through 1,000.
n <- 1000
n*(n+1)/2
#> [1] 500500

## 3. Look at the result of typing the following code into R, based on the result, what do you think the function seq and sum do?
## b. seq creates a list of numbers and sum adds them up.

## 4. use one line of code to compute the log, in base 10, of the square root of 100.
log(sqrt(100), base=10)
#> [1] 1

## 5. Which of the following will always return the numeric value stored in x? you can try out examples and use the help system if you want.
x=2
log(10^x)
log10(x^10)
log(exp(x))
exp(log(x, base=2))
## ans : log(exp(x))

## 2.4 Data types
a <- 2
class(a)
#> [1] "numeric"

## 2.4.1 Data frames
library(dslabs)
data(murders)

class(murders)
#> [1] "data.frame"

## 2.4.2 Examining an object

str(murders)
#> 'data.frame': 51 obs. of 5 variables:
#> $ state : chr "Albama" "Alaska" "Arizona" "Arkansas" ...
#> $ abb : chr "AL" "AK" "AZ" "AR" ...
#> $ region : Factor w/ 4 levels "Northeast", "South",..: 2 4 4 2 4 4 1 2 2 2 ...
#> $ population : num 4779736 710231 6392017 2915918 37253956 ...
#> $ total : num 135 19 232 93 1257 ...

head(murders)

#>    state       abb region population total
#> 1	Alabama	    AL	South  4779736	   135
#> 2	Alaska	    AK	West	  710231	    19
#> 3	Arizona	    AZ	West	 6392017 	   232
#> 4	Arkansas	  AR	South	 2915918	    93
#> 5	California	CA	West	37253956	  1257
#> 6	Colorado	  CO	West	 5029196	    65

## 2.4.3 The accessor: $
murders$population
#> [1]  4779736   710231  6392017  2915918 37253956  5029196  3574097   897934
#> [9]   601723 19687653  9920000  1360301  1567582 12830632  6483802  3046355
#> [17]  2853118  4339367  4533372  1328361  5773552  6547629  9883640  5303925
#> [25]  2967297  5988927   989415  1826341  2700551  1316470  8791894  2059179
#> [33] 19378102  9535483   672591 11536504  3751351  3831074 12702379  1052567
#> [41]  4625364   814180  6346105 25145561  2763885   625741  8001024  6724540
#> [49]  1852994  5686986   563626
## 값이 다른 건 그냥 data가 변한 것 때문이겠지? 내가 잘못한 거 아니겠지?

names(murders)
#> [1] "state" "abb" "region" "population "total"

## 2.4.4 Vectors: numerics, characters, and logical
pop <- murders$population
length(pop)
#> [1] 51

class(pop)
#> [1] "numeric"

class(murders$state)
#> [1] "character"

z <- 3 ==2
z
#> [1] FALSE

class(z)
#> [1] "logical"

## 2.4.5 Factors

class(murders$region)
#> [1] "factor"

levels(murders$region)
#> [1] "Northeast" "South" "North Central" "West"

region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN=sum)
levels(region)
#> [1] "Northeast" "North Central" "West"

## 2.4.6 Lists
record <- list()
record[['name']] <- 'John Doe'
record[['student_id']] <- 1234
record[['grades']] <- c('95','82','91','97','93')
record[['final_grade']] <- 'A'
record[['student_id']] <- 1234
record
#> $name
#> [1] "John Doe"
#>
#> $student_id
#> [1] 1234
#>
#> $grades
#> [1] 95 82 91 97 93
#>
#> $final_grade
#> [1] "A"
class(record)
#> [1] "list"

## 2.4.7 Matrices

mat <- matrix(1:12, 4, 3)
mat

#>      [,1] [,2] [,3]
#> [1,]    1    5    9
#> [2,]    2    6   10
#> [3,]    3    7   11
#> [4,]    4    8   12

mat[2, 3]
#> [1] 10

mat[2, ]
#> [1] 2 6 10

mat [,3]
#> [1] 9 10 11 12

mat[, 2:3]
#>      [,1] [,2]
#> [1,]    5    9
#> [2,]    6   10
#> [3,]    7   11
#> [4,]    8   12

mat[1:2, 2:3]
#>      [,1] [,2]
#> [1,]    5    9
#> [2,]    6   10

as.data.frame(mat)
#>  V1 V2 V3
#> 1 1	5	9		
#> 2 2	6	10		
#> 3 3	7	11		
#> 4 4	8	12		

data("murders")
murders[25, 1]
#> [1] "Mississippi"
murders[2:3,]
#>    state  abb region population total
#> 2	Alaska	AK	West	710231	   19
#> 3	Arizona	AZ	West	6392017	   232

## 2.5 Exercises

## 1. Load the U murders dataset.
str(murders)
## ans : c (It shows the name of the state, abbreviation, region, population and total number of murders.)

## 2. What are the column names used by the data frame for these five variables?
## ans : "state" "abb" "region" "population" "total"

## 3. Use the accessor $ to extract the state abbreviation and assign them to the object a. What is the class of this object?
murders$abb
a <- murders$abb
class(a)
#> [1] "character"
## ans : character

## 4. Now use the square brackets to extract the state abbreviations and assign them to the object b. Use the identical function to determine if a and b are the same.
murders[,2]
b <- murders[,2]
identical(a,b)
#> [1] TRUE
## ans : true (a and b are the same)

## 5.With one line of code, use the function levels and length to determine the number of regions defined by this dataset.
length(levels(murders$region))
#> [1] 4
## ans: 4

## 6. The function table takes a vector and returns the frequency of each element. you can quickly see how many states are in each region by applying this function. Use this function in one line of code to create a table of states per region.
table(murders$region)

#>  Northeast         South North Central          West 
#>          9            17            12            13


## 2.6 Vectors

## 2.6.1 Creating vectors

codes <- c(380, 124, 818)
codes
#> [1] 380 124 818

country <- c("italy", "canada", "egypt")

## 2.6.2 Names
codes <- c(italy=380, canada=124, egypt=818)
codes
#> italy canada  egypt 
#>   380    124    818 

class(codes)
#> [1] "numeric"

names(codes)
#> [1] "italy" "canada" "egypt"

codes <- c(380, 124, 818)
country <- c("italy", "canada", "egypt")
names(codes) <- country
codes
#> italy canada  egypt 
#>   380    124    818 

##2.6.3 Sequences
seq(1, 10)
#> [1] 1 2 3 4 5 6 7 8 9 10

seq(1, 10, 2)
#> [1] 1 3 5 7 9

1:10
#> [1] 1 2 3 4 5 6 7 8 9 10

class(1:10)
#> [1] "integer"

class(seq(1, 10, 0.5))
#> [1] "numeric"

## 2.6.4 Subsetting
codes[2]
#> canada
#>    124

codes[c(1,3)]
#> italy egypt
#>   380   818

codes[1:2]
#> italy canada
#>   380    124

codes["canada"]
#> canada
#>    124
codes[c("egypt", "italy")]
#> egypt italy
#>   818   380
```
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
